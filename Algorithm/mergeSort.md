# 병합 정렬 (MergeSort)  
  
분할 정복 방법의 알고리즘  
퀵정렬과 동일하게 O(N * logN) 시간 복잡도를 가진다. 하지만, 퀵 정렬은 편향되게 분할될 때 최악으이 경우 O(N ^ 2)의 시간 복잡도를 가진다.
이와 다르게 병합 정렬은 정확히 반절씩 나누기 때문에 최악의 경우에도 O(N * log N)을 보장한다. (항상 반으로 쪼개기 때문에 피벗 값이 없다.)

  
# 아이디어  
_* 일단 반으로 나누고 나중에 합쳐서 정렬하면 어떨까? _
  
# 예시  
7 6 5 8 3 5 9 1  

정렬이 되어있는 상태에서 새롭게 정렬이 된 상태를 만든다.  
합치는 순간! 정렬을 수행!
반으로 계속 나누어 원소 한 개씩 남을 때까지 나눈 결과로 부터 시작 함.
합칠 때는 2의 배수.
  
시작 : 7 | 6 | 5 | 8 | 3 | 5 | 9 | 1  
1(처음 합침. 2의 1 제곱) : 6 7 | 5 8 | 3 5 | 1 9 > 정렬이 되긴 했지만 2개씩 묶여있는 묶음 안에서만 정렬이 된 상태
2(두 번째 합침. 2의 2 제곱) : 6 7 과 5 8 을 비교, 3 5 와 1 9 비교해서 정렬 수행. 5 6 7 8 | 1 3 5 9  
3(세 번째 합침. 2의 3 제곱) : 1 3 5 5 6 7 8 9  
  
너비가 N 임. 데이터의 개수가 8개 이기 때문에 N = 8. 높이는 logN 이며 3 이다. 왜냐하면, log2의 8 이 3 이기 때문이다.  
(반반씩 쪼개어 들어갈 때 기본적으로 데이터 처리 개수는 2의 1 제곱, 2의 2 제곱, 2의 3제곱 이다.)  
  
# C 언어로 구현한 병합 정렬   
```C

#include <stdio.h>  

int number = 8;
int sorted[8]; // 정렬 배열은 반드시 전역변수로. 왜냐하면 정렬하기 위해 필요할 때마다 배열 생성하면 굉장히 비효율적 메모리 사용 
               // (정렬 배열 : 각 짒합들의 원소들을 정렬하여 최종 정렬이 완성된 배열 전에 원소들을 넣을 임시적 배열로써 사용 함)

// 시작점 : m , 중간점 : middle, 끝점 : n
void merge(int a[], int m, int middle, int n){
  int i = m;  // 1번 집합의 첫 원소 자리
  int j = middle + 1; // 2번 집합의 첫 원소 자리
  int k = m; // 새로운 집합의 첫 원소 자리
  // m     middle   n
  // 6 7     |      5 8 
  // 4 원소 가진 새 배열 k ( index 는 첫 번째 위치 부터 시작하기 때문에 i 와 동일한 위치임. 그래서 k = m )
  
  //작은 순서대로 배열에 삽입
  while( i <= middle && j <= n ){
    if( a[i] <= a[j] ) {
      sorted[k] = a[i];
    } else {
      sorted[k] = a[j];
      j++;
    }
    k++;
  }
  // 만약 1번 집합의 모든 원소가 2번 집합보다 새로운 배열 sorted에 먼저 전부 들어간다면, 남은 j 를 모두 넣어줘야함.
  // 혹은 만약 2번 집합의 모든 원소가 1번 집합보다 새로운 배열 sorted에 먼저 전부 들어간다면, 남은 i 를 모두 넣어줘야 함.
  // 남은 데이터들 삽입
  if( i > middle ) { // i 가 먼저 끝난 경우
    for( int t = j; t <= n; t++) { // 남은 j 값 전부 넣기
      sorted[k] = a[t];
      k++;
    } else { // j 가 먼저 끝난 경우
      for( int t = i; t <= middle; t++ ) { // 남은 i 값 전부 넣기
        sortedp[k] = a[t];
        k++;
      }
    }  
  }
  // 정렬된 배열을 삽입
  for( int t= m; t <= n; t++ ){
    a[t] = sorted[t]; // 모든 원소들을 정렬하여 실제 배열 a 에 담음
  }  
}

void mergeSort(int a[], int m, int n) { // 병합 정렬은 반으로 쪼개고 수행한다는 2 단계를 거치기 때문에 재귀 용법을 사용하는 것이 좋음
  // 크기가 1 보다 큰 경우
  if( m < n ) {
    int middle = ( m + n ) / 2; // 정중앙
    // 중앙 기점으로 왼쪽으로 병합 정렬
    mergeSort(a, m, middle);
    // 중앙 기점으로 오른쪽으로 병합 정렬
    mergeSort(a, middle + 1, n);
    merge(a, m, middle, n); // 두 집합을 합침
  }
}

int main(void){
  int array[number] = {7, 6, 5, 8, 3, 5, 9, 1};
  
  // 시작 인덱스 0 과 마지막 인덱스인 배열의 길이 - 1
  mergeSort(array, 0, number -1 );
  
  for( int i = 0; i < number; i++ ) {
    printf("%d ", array[i]);
  }

}

```
  
# 단점  
기존의 데이터를 담을 추가적인 배열 공간이 필요하다는 점에서 메모리 활용이 비효율적임
  
# 시간 복잡도  
O(N * logN)
