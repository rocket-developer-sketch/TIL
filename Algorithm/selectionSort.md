# 선택 정렬

## 소개
가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘

## 선택 정렬의 아이디어
**_"가장 작은 것을 선택해서 제일 앞으로 보내면 어떨까?"_

## 예시
1 10 5 8 7 6 4 3 2 9

가장 작은 1을 앞으로 보냄 ( 이미 1이 가장 앞에 있음. 이미 정렬이 되어있다라고 봄 ) -> 1 10 5 8 7 6 4 3 2 9
정렬 된 다음 원소(2 번 째)부터 끝까지 검색 ->
가장 작은 수 2를 검색한 범위의 원소들 중 가장 앞 으로 보냄. 해당 자리의 원소와 자리 바꿈  -> 1 2 5 8 7 6 4 3 10 9 ->
정렬 된 다음 원소(3 번 째)부터 끝까지 검색 ->
가장 작은 수 3을 검색한 범위의 원소들 중 가장 앞 으로 보냄. 해당 자리의 원소와 자리 바꿈 -> 1 2 3 8 7 6 4 5 10 9 ->
정렬 된 다음 원소(4 번 째)부터 끝까지 검색 ->
가장 작은 수 4를 검색한 범위의 원소들 중 가장 앞 으로 보냄. 해당 자리의 원소와 자리 바꿈 -> 1 2 3 4 7 6 8 5 10 9 ->
정렬 된 다음 원소(5 번 째)부터 끝까지 검색 ->
가장 작은 수 5를 검색한 범위의 원소들 중 가장 앞 으로 보냄. 해당 자리의 원소와 자리 바꿈 -> 1 2 3 4 5 6 8 7 10 9 ->
정렬 된 다음 원소(6 번 째)부터 끝까지 검색 ->
가장 작은 수 6를 검색한 범위의 원소들 중 가장 앞 으로 보냄. ( 이미 6이 가장 앞에 있음. 이미 정렬이 되어있다라고 봄 ) -> 1 2 3 4 5 6 8 7 10 9 ->
.
.
.

이런 식으로 끝까지 정렬을 진행하면 

1 2 3 4 5 6 7 8 9 10

순서로 정렬이 된다.

## C 언어로 작성된 선택 정렬 코드
```C
#include <stdio.h>

int main(void){
	
	//i 와 j는 반복적으로 배열의 원소들을 탐색하기 위함
	//min 은 최소값 : 가장 작은 것을 반복적으로 선택하기 위함
	//index 는 가장 작은 값이 존재하는 위치
	//temp 는 특정한 두 숫자를 바꾸기 위함
	int i, j, min, index, temp;
	
	// 정렬할 배열
	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
	
	for(i= 0; i < 10; i++){
		//모든 원소들 보다 큰 숫자 무작위로 넣어 줌
		min = 9999;
		
		// 한 사이클( 처음부터 끝 까지 )로, 탐색하면서 최소값 찾는 부분
		//j 는 i 부터 시작해서 10까지 반복 ( 정렬 후 , 다음 위치에서 부터 탐색 시작하니까 j 는 i 부터 시작 )
		for(j = i; j < 10; j++){ 
		
			//현재 탐색하고 있는 원소값이 현재 min 보다 값이 작다면,
			//min을 현재 탐색하고 있는 원소값으로 바꿔주기
			if(min > array[j]){	
				min = array[j];
				
				//현재 위치값을 index 에 저장
				index = j;		
			}
		}
		//가장 작은 값을 맨 앞으로 보내주기
		temp = array[i]; //임시적으로 현재 가장 앞에 있는 값 저장
		array[i] = array[index]; //가장 앞에 있는 값에 최솟값 저장
		array[index] = temp; //최솟값이 있던 위치에 가장 앞에 있었던 값 저장
			
	}
	
	for(i = 0; i < 10; i++){
		//출력
		printf("%d ", array[i]);
	}
	return 0;

}
```
## 시간 복잡도

1, 10, 5, 8, 7, 6, 4, 3, 2, 9 배열이 존재 한다면,

탐색 횟수는
10 + 9 + 8 + 7 + 6 + 5 ... 1 이 된다.
(
첫 번째 원소에서 끝까지 : 10 번 탐색
두 번째 원소에서 끝까지 : 9 번 탐색
세 번째 원소에서 끝까지 : 8 번 탐색
네 번째 원소에서 끝까지 : 7 번 탐색
.
.
.
기 때문에
)

이는 
**10  * (10 + 1) / 2 = 55** 로 계산 할 수 있다. 총 55번의 연산을 해야한다는 것을 구할 수 있다.
수식으로 나타낸다면, **N * (N + 1) / 2** 로 나타낼 수 있다.
컴퓨터에서는 2 로 나눈 값 같은 경우 N 이 아주 큰 값이라고 가정하기 때문에 산술은 무시하여
**N * N** 으로 볼 수 있으며,
**빅오 표기법(특정 알고리즘의 연산 횟수를 간단하게 표기)** 으로 나타낼 수 있다.


**_O(N * N) = O(N^2) **_


만약 선택 정렬해야 할 데이터의 갯수가 10,000개라면 대략 1 억 번 정도 계산을 하는 것.
데이터의 개수가 조금만 증가 해도 연산 횟수가 급격하게 늘어난다.


[출처] https://www.youtube.com/watch?v=8ZiSzteFRYc&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=2&t=4s













