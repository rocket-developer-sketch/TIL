버블 정렬

# 개념  
일련의 숫자들을 오름차순으로 정렬

# 아이디어
  
**_옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내면 어떨까?_  
  
옆에 있는 값과 비교하여 더 작은 값을 반복적으로 앞으로 보내는 정렬 방법  

# 선택 정렬과 다른 점
1 10 5 8 7 6 4 3 2 9
  
선택정렬이 탐색을 
첫 번째 부터, 1 10 5 8 7 6 4 3 2 9  
두 번째 부터, 10 5 8 7 6 4 3 2 9  
세 번째 부터, 5 8 7 6 4 3 2 9  
네 번째 부터, 8 7 6 4 3 2 9  
다섯 번째 부터, 7 6 4 3 2 9  
이런 식으로 하나씩 올라가면서 탐색을 하는 반면,  
  
버블 정렬은  
1 10 비교 후, 더 작은 숫자를 앞으로 옮김  
1 10 5 8 7 6 4 3 2 9  
그 다음 10 5 비교 후, 더 작은 숫자를 앞으로 옮김  
1 5 10 8 7 6 4 3 2 9  
그 다음 10 8 비교 후, 더 작은 숫자를 앞으로 옮김  
1 5 8 10 7 6 4 3 2 9  
이런식으로 당장 옆의 값과 비교를 한다.

# 예시
  
1 10 5 8 7 6 4 3 2 9  
첫 번째와 두 번째,1 10 -> 1 10 5 8 7 6 4 3 2 9  
두 번째와 세 번째, 10 5 -> 1 5 10 8 7 6 4 3 2 9  
세 번째와 네 번째, 10 8 -> 1 5 8 10 7 6 4 3 2 9  
네 번째와 다섯 번째, 10 7 - > 1 5 8 7 10 6 4 3 2 9  
다섯 번째와 여섯 번째, 10 6 -> 1 5 8 7 6 10 4 3 2 9  
여섯 번째와 일곱 번째, 10 4 -> 1 5 8 7 6 4 10 3 2 9  
이런 식으로 정렬이 계속해서 이루어져 결과적으로  
1 2 3 4 5 6 7 8 9 10  
으로 정렬이 완료 된다.  

1 10 5 8 7 6 4 3 2 9    
1 10 5 8 7 6 4 3 2  
1 10 5 8 7 6 4 3  
1 10 5 8 7 6 4  
1 10 5 8 7 6  
처럼 뒤에서 부터 비교 집합의 크기가 줄어든다.
```C
# C코드로 구현된 버블정렬  
#include <studio.h>  

int main(void){
  // 반복을 위한 i, j 
  // 서로 다른 수로 교환하기 위한 temp
  int i, j , temp;
  // 정렬할 배열
  int array[10] = { 1 , 10, 5, 8, 7, 6, 4, 3, 2, 9 };
  
  for(i = 0; i < 10; i++) { 
    // 버블 정렬같은 경우, 뒤에서 부터 집합의 크기를 하나씩 감소시키는 특징 때문에 9 - i 하나씩 빼줌
    for(j = 0; j < 9 - i; j++){
      // 기준값 을 바로 옆 값과 비교 하여 더 클 때는,
      if(array[j] > array[j +1]){
        temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
  }  
  
  //출력
  for(i = 0; i < 10; i++) {
    printf("%d". array[i]);
  }
  return 0;
}
```
  
# 시간 복잡도
1 2 3 4 5 6 7 8 9 10
비교 연산 횟수는
1 2 3 4 5 6 7 8 9 10  
1 2 3 4 5 6 7 8 9  
1 2 3 4 5 6 7 8  
1 2 3 4 5 6 7  
처럼 하나씩 줄어들면서 비교하기 때문에  
10 + 9 + 8 + 7 + 6 + 5 + ... 1 (등차수열)  
이기 때문에 N * (N + 1) / 2 이며, N이 큰 숫자일 때는 + 1 이나 / 2 가 소용이 없기 때문에,  
O(N * N)으로 표현한다. 즉, N^ 이다.  
  
선택 정렬과 같은 시간 복잡도를 가지지만, 훨씬 느리다.  
그 이유는,  
자리를 바꾸는 연산은 위에 코드를 보면 3줄로 이루어져 있다.
버블 같은 경우 당장 옆에 있는 것과 비교하여 자리를 바꾸는 연산을 사용한다. 그래서 매번 자리 바꾸는 연산이 실행된다.   
선택 같은 경우 모든 원소를 탐색하고 한 번 자리를 바꾸는 연산을 사용한다.  
그렇기 때문에 실제로 버블이 선택보다 실제 수행시간이 훨씬 느리며, 비효율 적이다.  
정렬 알고리즘 중에 가장 느린 정렬 알고리즘 이기도 하다.






