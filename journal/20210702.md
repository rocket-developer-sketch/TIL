# [20210702 logN, NlogN 이라는 시간복잡도]

logN이라는 시간 복잡도는 어디에서 올까?

이진검색트리에서
총 12개의 노드가 있는 이진탐색트리가 있다고 생각한다면 한 번 탐색할 때마다  
12 => 6 => 3 => 1 로 줄어들어 3번의 시행으로 원하는 노드를 찾아낼 수 있다는 분할을 생각하면 logN 시간이 무엇인지 조금 가닥이 
잡힐 것이다.

잠시 아래에 시간복잡도의 의미를 정리해보자면, 

O(1): 입력 데이터 크기 상관없이 입력하더라도 1번 실행하는 알고리즘
O(n): 입력 데이터 크기에 비례해서 처리 시간 증가
O(n^2): 입력 데이터 크기 만큼 반복되는 반복문이 2개.
  n X n 행렬로 나타낼 수 있는 데, 입력 데이터 크기가 x씩 늘어 날 때마다 (n + x) X (n + x) 행렬이 생기며 면적이 넓어지는 그림형태 
O(nm) : 입력 데이터 크기 n 만큼 반복되는 반복문 안에 입력 데이터 크기 m 만큼 반복되는 반복문으로 2개 존재.
  n X m 행렬로 나타낼 수 있다.
O(n^3) : 입력 데이터 크기 만큼 반복되는 반복문이 3개. n^2 이 n개
O(2^n) : 재귀함수. 매번 함수를 호출 할 때 마다 2번 씩 함수 호출(트리로 그림). 이것을 트리 높이 만큼 반복
O(logN): 이진검색트리가 대표적인 예시. 분할되며 2씩 검색범위가 줄어듦. 2인 이유는 프로그래밍에서 log의 밑지수는 2이기 때문이다.

정렬 알고리즘으로 시간 복잡도에 대한 이해를 완전히 익혀야겠다고 생각이 들며, 
역시 알고리즘의 기본은 정렬 알고리즘이라는 것을 세삼 깨닫게 된다.

그렇다면 퀵정렬 같은 경우 시간 복잡도가 NlogN인데 그 이유는?

잠시 중간 저장!






*어제의 나보다 조금 더 나은 나를 위하여*
