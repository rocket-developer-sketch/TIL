# [20210702 logN, NlogN 이라는 시간복잡도]

logN이라는 시간 복잡도는 어디에서 올까?

이진검색트리에서
총 12개의 노드가 있는 이진탐색트리가 있다고 생각한다면 한 번 탐색할 때마다  
12 => 6 => 3 => 1 로 줄어들어 3번의 시행으로 원하는 노드를 찾아낼 수 있다는 분할을 생각하면 logN 시간이 무엇인지 조금 가닥이 
잡힐 것이다.

잠시 아래에 시간복잡도의 의미를 정리해보자면,   

O(1): 입력 데이터 크기 상관없이 입력하더라도 1번 실행하는 알고리즘  
O(n): 입력 데이터 크기에 비례해서 처리 시간 증가  
O(n^2): 입력 데이터 크기 만큼 반복되는 반복문이 2개  
  n X n 행렬로 나타낼 수 있는 데, 입력 데이터 크기가 x씩 늘어 날 때마다 (n + x) X (n + x) 행렬이 생기며 면적이 넓어지는 그림형태   
O(nm) : 입력 데이터 크기 n 만큼 반복되는 반복문 안에 입력 데이터 크기 m 만큼 반복되는 반복문으로 2개 존재.  
  n X m 행렬로 나타낼 수 있다.  
O(n^3) : 입력 데이터 크기 만큼 반복되는 반복문이 3개. n^2 이 n개  
O(2^n) : 재귀함수. 매번 함수를 호출 할 때 마다 2번 씩 함수 호출(트리로 그림). 이것을 트리 높이 만큼 반복  
O(logN): 이진검색트리가 대표적인 예시. 분할되며 2씩 검색범위가 줄어듦. 2인 이유는 프로그래밍에서 log의 밑지수는 2이기 때문이다.  
  
정렬 알고리즘으로 시간 복잡도에 대한 이해를 완전히 익혀야겠다고 생각이 들며,   
역시 알고리즘의 기본은 정렬 알고리즘이라는 것을 세삼 깨닫게 된다.  

#### 퀵정렬 같은 경우 시간 복잡도가 NlogN인데 그 이유는?

피벗값이 이상적으로 주어진 데이터의 중간값으로 정해진 상황이라는 가정하에,
원소끼리의 비교하는 것을 제외하고 먼저 생각해보겠다.
피벗값을 중심으로 분할이 될 것이다. 
1,2,3,4,5,6,7,8 이 존재한다고 할 때,  
총 분할 횟수는 8=>4=>2=>1 이 될 것이고,  
즉, logN 의 시간복잡도를 가지게 되는 것이다.  
그리고, 왼쪽 인덱스는 분할 된 집합 내에서 키 값 보다 작은 값을 만날 때까지 인덱스 값을 증가시키고,
오른쪽 인덱스는 분할 된 집합 내에서 키 값 보다 큰 값을 만날 때까지 인덱스 값을 감소 시켜
데이터 입력 크기 N 번 만큼 탐색한다는 것을 알 수 있다.

그렇기 때문에 퀵 정렬의 시간 복잡도는 NlogN이 되는 것이다.


*어제의 나보다 조금 더 나은 나를 위하여*
